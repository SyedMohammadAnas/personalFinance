# PROJECT VERSIONS

## Version 1

### Next.js Application with Google Authentication and Supabase: A Technical Journey

Our project is a modern web application built with Next.js 14, leveraging its App Router architecture to create a seamless user experience with server and client components. We've implemented a robust authentication system using NextAuth.js with Google OAuth, allowing users to sign in securely with their Google accounts. For data persistence, we integrated Supabase as our backend service, which provides a PostgreSQL database with Row Level Security policies to ensure data privacy. The application follows a clean separation of concerns: the `/app` directory contains route-specific components, `/components` houses reusable UI elements, and `/lib` stores utility functions and service integrations. This architecture follows industry best practices by separating UI, business logic, and data access layers, making the codebase maintainable and scalable.

Authentication presented several interesting challenges we methodically solved. First, we needed to create proper sign-in and error pages in the `/auth` directory to match NextAuth's configuration. When users attempt to sign in, they trigger the Google OAuth flow through our client-side button component (marked with "use client" directive). After successful authentication, NextAuth's callback processes the user information and stores it in Supabase using our custom `upsertUser` function. We encountered and resolved React hydration errors that occurred when mixing server and client-side rendering - a common Next.js pitfall - by carefully structuring our components. By implementing server-side session checks and client-side interactivity, we created a seamless authentication experience that handles edge cases gracefully.

For user profile management, we created a system that combines data from two sources: basic information from Google OAuth and additional user metadata from Supabase. We designed a simplified `UserData` type that includes essential fields like id, email, name, and profile image URL. The profile page fetches user data server-side and displays it in a clean, left-aligned card layout. To handle potential database connectivity issues, we implemented graceful degradation through placeholder data in case Supabase queries fail. We originally tracked timestamps for user creation and last login but later simplified the schema by removing these fields based on evolving requirements. The Supabase integration layer includes comprehensive error handling for various scenarios, from table existence checks to unique constraint violations, ensuring robust user data management even under unexpected conditions.

The most technically challenging aspect was handling profile images, particularly those from Google's CDN which sometimes time out or fail to load. We engineered a resilient `ProfileImage` component that implements several advanced techniques: automatic retries when browser tabs regain visibility, timeout detection with fallback icons, and cache-busting for Google image URLs to prevent stale caches. This component uses React's useEffect and useRef hooks to manage loading states and network requests efficiently. We solved hard-to-debug React hydration mismatches by avoiding dynamic values during initial renders and moving timestamp generation to client-side effects. The UI design throughout the application follows a consistent approach using shadcn components styled with Tailwind CSS, ensuring responsive behavior across devices. This attention to detail in handling edge cases, particularly around image loading and authentication flows, demonstrates how production-quality applications must anticipate and gracefully handle failure modes beyond the happy path.
